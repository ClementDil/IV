<!DOCTYPE html>
<meta charset="utf-8">
<style>
.bar { fill: steelblue; }
.bar2 { fill: rgb(180, 114, 70); }
.container {
    position: absolute;
    top: 20px; 
    left: 15%;
    transform: translateX(-50%);
    overflow-y: auto; 
    max-height: 300px; 
}

.year-container {
    position: absolute;
    top: 20px; /* Adjust as needed */
    left: 30%; /* Adjust as needed */
    transform: translateX(-25%); /* Adjust as needed */
}
</style>
<body>

      <div id="tooltip" style="position: absolute; visibility: hidden; background-color: #fff; border: 1px solid #ddd; padding: 5px; border-radius: 3px; pointer-events: none;"></div>


<!-- Load the d3.js library -->
<script src="https://d3js.org/d3.v6.min.js"></script>
<script>

var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 2000 - margin.left - margin.right,
    height = 2000 - margin.top - margin.bottom, // Making height equal to width for a more centered square area
    innerRadius = 180,
    outerRadius = Math.min(width, height) / 5 ; // The outerRadius should be half of the width or height, whichever is smaller

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + (width / 2 + margin.left) + "," + (height / 2 + margin.top) + ")");


d3.csv("full-data-comma.csv").then(function(data) {
  var years = ['2000','2013','2014','2015','2016','2017','2018','2019','2020','2021'];
  //var years = Object.keys(data[0]).slice(1); // Exclude the 'Country Name' column
  var selectedYear = years[0]; // Set initial selected year
  console.log(selectedYear);

  var yearContainer = d3.select("body")
    .append("div")
    .classed("year-container", true);

  var select = yearContainer
    .append("select")
    .on("change", updateGraph);


  select.selectAll("option")
    .data(years)
    .enter().append("option")
    .text(function(d) { return d; });

  // Create checkboxes for each country
  var countrySelectionDiv = d3.select("body").append("div")
    .classed("container", true);
  var selectAllCheckbox = countrySelectionDiv.append("input")
    .attr("type", "checkbox")
    .attr("id", "selectAllCountries")
    .attr("checked", true) // Initially checked
    .on("change", function() {
        var isChecked = this.checked;
        // Update individual checkboxes
        d3.selectAll("input[name='countryCheckbox']").each(function() {
            this.checked = isChecked;
        });
        updateGraph(); // Update the graph when selection changes
    });

countrySelectionDiv.append("label").text("Select All");

// Create checkboxes for each individual country
data.forEach(function(d) {
    countrySelectionDiv.append("input")
        .attr("type", "checkbox")
        .attr("name", "countryCheckbox")
        .attr("value", d['Country Name'])
        .attr("checked", true) // Initially checked
        .on("change", function() {
            updateGraph(); // Update the graph when individual checkboxes change
        });
    countrySelectionDiv.append("label").text(d['Country Name']);
    countrySelectionDiv.append("br");
});



function updateGraph() {
  svg.selectAll(".bar, .bar2").remove();
  svg.selectAll("text").remove();
  selectedYear = select.node().value; // Update selected year from dropdown

  var colorScale = d3.scaleSequentialLog(t => d3.interpolatePuBuGn(t))  // ... (the rest of your code above remains unchanged)

  var selectedCountries = [];
  d3.selectAll("input[name='countryCheckbox']:checked").each(function() {
    selectedCountries.push(this.value);
  });
  var columnDContent = data.map(row => row.selectedYear+'_wom');
  var filteredData = data.filter(d => selectedCountries.includes(d['Country Name']) && +d[selectedYear+'_wom'] != -1000)
    .map(d => ({
      country: d['Country Name'],
      value: +d[selectedYear+'_wom'],
      le: +d[selectedYear+'_le'],
      gdp: +d[selectedYear+'_gdp']
    }));

  // Sort data by value descending
  filteredData.sort((a, b) => b.value - a.value);

  // Calculate mean and standard deviation
var mean = d3.mean(filteredData, function(d) { return d.value; });
var std = d3.deviation(filteredData, function(d) { return d.value; });

// Scale data using z-score normalization
filteredData.forEach(function(d) {
    d.normalizedValue = (d.value - mean) / std;
});

// Use normalizedValue for visualization



  
  // Determine the minimum and maximum values after sorting
  var minValue = filteredData[filteredData.length - 1].value;
  var maxValue = filteredData[0].value;

  var numBars = filteredData.length;

  var x1 = d3.scaleBand()
    .range([0, 2 * Math.PI])
    .align(0)
    .padding(0.1)
    .domain(filteredData.map(function(d) { return d.country; }));

  var y1 = d3.scaleLinear()
    .range([145, 180])
    .domain([0, maxValue]);

    filteredData.sort((a, b) => d3.ascending(a.value, b.value));
    
  var innerRadius2 = 160;
    
  var arc2 = d3.arc()
    .innerRadius(innerRadius2)
    .outerRadius(d =>y1(0.0005)) // Use max to prevent negative values from creating inner radius bars
    .startAngle(d =>x1(d.country))
    .endAngle(d =>x1(d.country) +x1.bandwidth()) // Use the bandwidth for the bar width
    .padAngle(0.01)
    .padRadius(innerRadius2);

  var x = d3.scaleBand()
    .range([0, 2 * Math.PI])
    .align(0)
    .padding(0.1)
    .domain(filteredData.map(function(d) { return d.country; }));

  var y = d3.scaleLinear()
    .range([innerRadius, outerRadius])
    .domain([0, maxValue]);
  // Sort data by value ascending to ensure proper layering
  filteredData.sort((a, b) => d3.ascending(a.value, b.value));

  var arc = d3.arc()
    .innerRadius(innerRadius)
    .outerRadius(d => y(Math.max(d.value, 0))) // Use max to prevent negative values from creating inner radius bars
    .startAngle(d => x(d.country))
    .endAngle(d => x(d.country) + x.bandwidth()) // Use the bandwidth for the bar width
    .padAngle(0.01)
    .padRadius(innerRadius);

    
    var bars = svg.selectAll(".bar")
        .data(filteredData)
        .enter()
        .append("path")
        .attr("class", "bar")
        .attr("d", arc)
        .style("fill", function(d){
        console.log("Data value: " + d.value + ", Color: " + colorScale(d.value)); // Log the data value and corresponding color
        return colorScale(d.value);
    });

    // Apply transition to update bars smoothly
    bars.transition()
        .duration(1000)
        .attrTween("d", function(d) {
            var interpolate = d3.interpolate(0, d.value);
            return function(t) {
                d.value = interpolate(t);
                return arc(d);
            };
        });

    bars.exit().remove();

       var tooltip = d3.select("#tooltip");

bars.on("mouseover", function(event, d) {
        tooltip.style("visibility", "visible")
            .text("Value: " + d.value); // Set the text of the tooltip as the data value
    })
    .on("mousemove", function(event, d) {
        tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");
    })
    .on("mouseout", function() {
        tooltip.style("visibility", "hidden");
    });


    // bar chart with varying colors
  svg.selectAll(".bar2")
    .data(filteredData)
    .enter()
    .append("path")
    .attr("class", "bar2")
    .attr("d", arc2)
    .transition()
    .duration(1000)
    .style("fill", function(d){
        console.log("Data value: " + d.le + ", Color: " + colorScale(d.le*0.05)); // Log the data value and corresponding color
        return colorScale(d.le*0.05);
    });
  
    var labelOffset = 100; // Increase or adjust this value to control the distance of labels from the bars

svg.append("g")
  .selectAll("text")
  .data(filteredData)
  .enter()
  .append("text")
  .attr("text-anchor", "middle")
  .attr("transform", function(d) {
    // Calculate the angle for each label
    var angle = x(d.country) + x.bandwidth() / 2; // Midpoint of the bar
    var angleDegrees = (angle * 180 / Math.PI) - 90; // Convert to degrees, adjust for label orientation
    var radius = y(d.value) + labelOffset; // Add labelOffset to distance from center to end of the bar

    // Calculate position with the updated radius
    var xPosition = radius * Math.cos(angle - Math.PI / 2);
    var yPosition = radius * Math.sin(angle - Math.PI / 2);

    return "translate(" + xPosition + "," + yPosition + ") rotate(" + angleDegrees + ")";
  })
  .text(function(d) { return d.country; });










}

// Initial graph render
updateGraph();




});

</script>
</body>
